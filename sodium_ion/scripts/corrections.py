"""Script to compute the charging free energy corrections, according to 
Rocklin paper"""
import parmed                   #parmed module is used to deal with TOP and CRD 
                                #and pqr format
from parmed.amber import *      #parmed amber module
import mdtraj as md             #mdtraj 1.9.1
import os, math
import numpy as np
import sys

"""Here I am defining global variables"""

PoissonNPSolverBin= "/home/steboss/local/apbs/bin/apbs"  #APBS 1.4.1
psi_ls = -2.837297                                       # PME constant
xi_CB = 2.38008                                          #see eq. (21) of Rocklin paper
pi = math.pi
coulomb_factor = 138.93545585                           # (4*pi*eps_0)**-1 in (kJ nm)/(e**2 mol)
#TODO: check if the coulomb_factor does have an impact in our estimation. Compare this value to the 
#one of the  Poisson PBC solver (Hunenberger code)
kB = 0.0083144621                                        # kJ/(mol K)  
T = 298                                                  # K
kBT = kB * T                                    
eps_solv = 82.0                                          # TIP3P dielectric



###################### PQR CONVERSION #########################################
def general_pqr(pqrfile):
    r"""This function converts the PQR file generated by parmed 
    into a PQR readable for APBS
    Parameters
    ----------
    pqrfile:            string
                        path of the pqr file generated by parmed
    
    Returns
    -------
    """

    #recreate the pqr according to Rocklin standard,
    #so start with ATOM and no END
    ifile = open(pqrfile,"r")  #open the PQR file
    ifilereader = ifile.readlines()  #read the lines
    ofile = open("free_tmp.pqr","w") #create a temporary pqr file

    #substitue everything at the beginning with ATOM
    for line in ifilereader:
        splitter = line.split()
        if splitter[0]!="HETATM": 
            continue
        else:
            copy = "ATOM"+ line[6:]
            ofile.write(copy)

    ofile.close()
    ifile.close()
    #rename the file
    cmd = "mv free_tmp.pqr free.pqr"
    os.system(cmd)
    #now proced with the APBS calculations



def ligand_only(pqrfile,lig_name):
    r"""ligand_only extracts the ligand information 
    from the PQR file, while the protein charges are set to 0.0

    Parameters
    ----------
    pqrfile:            string  
                        path of the original pqr file
    
    lig_name:           string
                        name of the ligand
    
    Returns
    -------
    """
    #here we want the ligand to have charges
    #while the protein 0.0          
    ifile = open(pqrfile,"r").readlines()
    ofile = open("ligand_only.pqr","w")

    for line in ifile:
        res_name = line.split()[3]
        if res_name==lig_name:
            lig_atnumb = int(line.split()[1])
            lig_atom = line.split()[2]
            lig_chain = int(line.split()[4])
            lig_xx = float(line.split()[5])
            lig_yy = float(line.split()[6])
            lig_zz = float(line.split()[7])
            lig_charge = float(line.split()[8])
            lig_radius = float(line.split()[-1])
            #print(std_string)
            ofile.write("ATOM  %5d %-3s  %-3s   %3d    %7.3f %7.3f %7.3f %8.4f %8.4f\n" % (lig_atnumb,lig_atom,lig_name,lig_chain,\
                                                                                            lig_xx,lig_yy,lig_zz,lig_charge,lig_radius))
        else:
            res_atnumb = int(line.split()[1])
            res_atom = line.split()[2]
            res_name = line.split()[3]
            res_chain = int(line.split()[4])
            res_xx = float(line.split()[5])
            res_yy = float(line.split()[6])
            res_zz = float(line.split()[7])
            res_charge =0.0000
            res_radius = float(line.split()[-1])
            #print(std_string)
            ofile.write("ATOM  %5d %-3s  %-3s   %3d    %7.3f %7.3f %7.3f %8.4f %8.4f\n" % (res_atnumb,res_atom,res_name,res_chain,\
                                                                                            res_xx,res_yy,res_zz,res_charge,res_radius))

    ofile.close()


"""Here we start with the correction terms routines"""
#################CORRECTION TERMS##########################################

#NET
def compute_net(qprot,qlig,box_edge):
    r""" Compute DG_NET term, from eq. 15 of Rocklin paper

    Parameters
    -----------
    qprot:      double
                protein total net charge 

    qlig:       double
                ligand total net charge

    box_edge:   double
                length of the box -- even if the box sizes are not the same 
                we are supposing this could be a reasonable approximation 

    Returns
    -------
    DGnet:      double
                DG net free energy in kJ/mol
    """

    #coulomb_factor =(4*pi*eps_0)**-1
    # pi*coulomb_factor = (4*eps_0)**-1
    # (1/2)*coulomb above
    coulomb_8pi = (pi/2)*(coulomb_factor)
    DGnet = -(psi_ls/coulomb_8pi)*((qprot+qlig)**2 - qprot**2)*(1/box_edge)
    #DG net units are kJ/mol
    return DGnet

#USV
def compute_usv(qprot,qlig,box_edge):
    r""" Compute DG_NET term, from eq. 16 of Rocklin paper

    Parameters
    -----------
    qprot:      double
                protein total net charge 

    qlig:       double
                ligand total net charge

    box_edge:   double
                length of the box -- even if the box sizes are not the same 
                we are supposing this could be a reasonable approximation 

    Returns
    -------
    DGusv:      double
                DG usv free energy in kJ/mol
    """

    coulomb_8pi = (pi/2)*(coulomb_factor)
    DGusv = (psi_ls/coulomb_8pi)*(1-(1/eps_solv))*((qprot+qlig)**2 - qprot**2)*(1/box_edge)

    #units in kJ/mol
    return DGusv



######RIP CALCULATION######
def compute_rip(qprot,qlig,bound_edge):
    r""" Compute DG_NET term, from eq. 17 of Rocklin paper
    For solvation free energies qprot=0.0

    Parameters
    -----------
    qprot:      double
                protein total net charge 

    qlig:       double
                ligand total net charge

    box_edge:   double
                length of the box -- even if the box sizes are not the same 
                we are supposing this could be a reasonable approximation 

    Returns
    -------
    RIP_free:   double
                DG rip free energy in kJ/mol for the solvated phase
    
    RIP_lig:    double
                value of the integration over the electrostatic potential -- this is not a free energy (eq. 18 Rocklin)
    """

    #first compute the electrostatic potential in presence of dieelctric constant 
    print("Performin the APBS calculation...")
    apbs_rip(eps_solv) #here we are computing the electrostatic potential of the solute
    #and we are saving it onto a grid file dx
    print("Running APBS for RIP calculations ...")
    cmd = "%s  apbs.in 1>std.out 2>std.err"  % PoissonNPSolverBin
    os.system(cmd)


    #Now we are performing the integration over the space (dx file)
    #to comput ethe DG_rip quantity in a heterogenous cavity
    print("Reading the protein_RIP.dx and ligand_RIP.dx")
    #dxfile for the protein and ligand:
    dx_ligand  = "ligand_RIP.dx"
    #read the APBS potentialmaps for ligand  --This part of the code is exactly the same 
    #as the one  written by Rocklin
    apbs_ligand = open(dx_ligand,"r")
    lines_ligand = apbs_ligand.readlines()
    apbs_ligand.close()
    #due to the nature of the calculation we assume that the spacing 
    #on the x axis is the same for y and z 
    spacing_ligand = float(lines_ligand[6].split()[1])
    #eliminate all the other non-data lines:
    lines_ligand  = filter(lambda x: x[0] in "0123456789-.", lines_ligand)
    tot_pot_lig = 0.0 # ligand total potential
    numpts_lig = 0 # number of points for the ligand grid

    print("Integration...")
    for line in lines_ligand:
        tot_pot_lig+=sum([float(x) for x in line.split()])
        numpts_lig+= len(line.split())
    #compute the volume in nm^3:
    V_lig = (((spacing_ligand**3)/1000.0)*numpts_lig)
    #B_HET[L,apbs_box] -- eq. 21  Rocklin
    B_lig = tot_pot_lig*kBT*V_lig/numpts_lig
    #and B_HET[Qlig,apbs_box]  -- eq.20 Rocklin
    B_Q_lig = ((qlig * xi_CB * coulomb_factor / eps_solv * (V_lig ** (2.0 / 3.0))))
    print("Carrying out all the numbers...")
    #this are the integrals from the apbs cubic box size
    RIP_lig  = B_lig - B_Q_lig     #to be converted to kcal by /4.184
    RIP_free  = ((RIP_lig*qlig))*(1/free_edge**3)
    return(RIP_free,RIP_lig)  #these will be in kJ
    

def apbs_rip(epsilon):
    r""" This function uses APBS to compute. APBS compute the electrostatic 
    potential in the space for the solute. 
    Then, everting is save into a grid file  "dx".
    This electrostatic potential will be then integrated for the case of a
    heterogenous cavity

    Parameters
    -----------
    epsilon:      double
                  solvent dielectric constant 

    Returns
    -------
    """

    #create a apbs.in file as input for APBS
    ifile = open("apbs.in","w")

    #Here we are creating an input file for APBS using the option 
    # mg-manual
    # we define 257 points in the X, Y and Z directions to create a grid
    # the grid is centered onto the solute (gcent mol 1)
    # we are computing a linear poisson boltzmann equation (lpbe)
    #
    ifile.write("""# READ IN MOLECULES
read 
    mol pqr %s    
end

# CALCULATE POTENTIAL WITH ONLY THE LIGAND CHARGES
elec name free
    mg-manual
    dime 257 257 257
    glen 120 120 120
    gcent mol 1
    mol 1
    lpbe
    bcfl mdh
    pdie 1.0
    sdie %.1f
    chgm spl4
    srfm smol
    srad 1.4
    swin 0.3
    sdens 40.0
    temp 298.0
    calcenergy no
    calcforce no
    write pot dx ligand_RIP
end

# SO LONG
quit""" %("free.pqr",epsilon) )

    ifile.close()
    #run apbs



###################################################

#EMP
def compute_emp(qprot,qlig,res_int_lig,bound_edge):
    r""" compute_emp computes the DG emp term  eq.25 Rocklin 

    Parameters
    ----------
    qprot:      double
                protein charge value (0.0 for solvated phase)
    
    qlig:       double
                ligand charge value
    
    res_int_lig:    double
                residual integral of the ligand only, eq. 18 Rocklin (computed in compute_rip)
    
    bound_edge: double
                length of the simulation box

    Returns
    -------
    DGemp:      double
                DG emp free energy in kJ/mol"""
    
    #res_int_lig is the ligand residual integral
    #first perform the calculation of I_L,SLV eq 27 Rocklin
    #compute the homogeneous ligand integral
    print("Computation of the ligand vacuum potential...")
    apbs_rip(1.0)  #here we are computing the solute electrostatic potential
    #in presence of a homogenous cavity, namely a space with dielectric = 1.0 

    #here we extract the free energy as in compute_rip
    #dxfile for the ligand:
    dx_ligand  = "ligand_RIP.dx"
    #next charge forligand qlig
    #read the APBS potential map
    apbs_ligand = open(dx_ligand,"r")
    lines_ligand = apbs_ligand.readlines()
    apbs_ligand.close()
    #due to the nature of the calculation we assume that the spacing 
    #on the x axis is the same for y and z 
    spacing_ligand = float(lines_ligand[6].split()[1])
    #eliminate all the other non-data lines:
    lines_ligand  = filter(lambda x: x[0] in "0123456789-.", lines_ligand)

    tot_pot_lig = 0.0 # ligand total potential
    numpts_lig = 0 # number of points for the ligand grid

    print("Integration...")

    for line in lines_ligand:
        tot_pot_lig+=sum([float(x) for x in line.split()])
        numpts_lig+= len(line.split())
    #compute the volume in nm^3: 
    V_lig = (((spacing_ligand**3)/1000.0)*numpts_lig)

    #B_HOM[L,apbs_box]
    B_hom_lig = tot_pot_lig*kBT*V_lig/numpts_lig
    #and B_HOM[Q_lig,apbs_box]
    B_Q_hom_lig = ((qlig * xi_CB * coulomb_factor / 1.0 * (V_lig ** (2.0 / 3.0))))
    print("Carrying out all the numbers...")
    #this are the integrals from the apbs cubic box size #units kJ nm^3/(mol e)
    RIP_hom_lig  = B_hom_lig - B_Q_hom_lig     #to be converted to kcal by /4.184
    #now compute I_L,SLV:
    I_L_SLV = res_int_lig - (B_hom_lig - B_Q_hom_lig) 
    print("Solvation contribution to the residual integrated potential I_L, I_L_SLV = %.4f  kJ nm^3/(mol e)" % (I_L_SLV))
    ####################################################################################

    #now compute the protein-ligand  ligand radius:  eq. 26 Rocklin
    R_L_first = (coulomb_factor/2)*(4*pi/3.0)*(1- (1/eps_solv))*(qlig)  #first part
    #then cmopute the inverse of R_L_first and multiply by I_L_SLV aand take the sqrt
    R_L = ((R_L_first)**-1) * (I_L_SLV)
    R_L = math.sqrt(R_L) #nm length
    print("Ligand radius in the bound phase R_L = %.4f nm" % (R_L))
    #TODO we should tae into consideration the case where q_prot is 0, 
    #namely the sodium ion 
    DGemp = (-coulomb_factor/2)*( (16/45)*pi**2)*(1-(1/eps_solv))*((qprot + qlig)**2 - (qprot**2))*((R_L**5)/(bound_edge**6))
    #print("Empirical correction DGemp %.4f kJ" % (DGemp))
    return DGemp

#DSC
def compute_dsc(nwater,qlig,box_edge):
    r"""compute_dsc takes into account the "PSUM"/ charge sorting correction

    Parameters
    ----------
    nwater:     int
                number of water molecules in the simulation box

    qlig:       double
                ligand net charge
    
    box_edge:   double
                box edge size

    Returns
    -------
    DGdsc:      double
                DG dsc value kJ/mol"""
    #the quadrupole trace for tip3p water is 0.007 e nm^2
    gamma = 0.007 # e nm^2
    eps0 = (1/6.0)*coulomb_factor*4*pi  #6*epsilon_0 permittivity
    DGdsc = - (gamma*qlig)*(eps0)*(nwater/box_edge**3)
    return DGdsc



####################################################################
########MAIN#####################

dcd = sys.argv[1]  #read the trajectory
top = sys.argv[2]  #top must be prmtop  --> SYSTEM.prmtop
print("Loading the trajectory...")
md_dcd = md.load_dcd(dcd,top=top)
step = 100
print("Total number of frames analysed:%d" % (len(md_dcd)/step))

#Save all the terms into lists
dg_nets = []
dg_usvs = []
dg_emps = []
dg_rips = []
dg_dscs = []
dg_cors = []
#now cycle through all the frames
for i in range(0,len(md_dcd),step ):
    print("Analysing frame %d" % i)
    frame = md_dcd[i]  #select the frame
    #create a folder
    folder = "analysis-%d" % i   #create a folder for the computation
    os.mkdir(folder) 
    os.chdir(folder)             #change into this folder
    #start with the analysis
    #convert the frame  into amberrst7
    frame.save_amberrst7("SYSTEM.crd")  #save a coordinate file for this frame
    
    base = AmberParm("../SYSTEM.prmtop","SYSTEM.crd")  #load the topology and the new coord frame

    #compute the ligand net charge and the number of waters -- do it just once (i==0)
    if i==0 :
        qlig = 0.0
        #assuming th eligand is the first residue
        for at in base.residues[0].atoms:
            qlig+=at.charge
        print("Total ligand charge %.2f" % (qlig))

        wat = 0 
        for res in base.residues:
            if res.name=="WAT":
                wat+=1
    
    
    #take the edge of the box in nm
    free_edge = base.box[0]/10  #nm
    #strip out water and ions for the moment
    base.strip(":WAT")
    #create a PQR file
    print("Creating PQR file...")
    parmed.formats.PQRFile.write(base,"free.pqr")
    #with parmed 2.0.9 general_pqr and APBS 1.4.1 is not necessary 
    #to call the general_pqr function
    #generalise the pqr
    #general_pqr("free.pqr")
    #compute the correction terms
    #NET
    dg_net_free = compute_net(0.0,qlig,free_edge)
    print("DG_net %.4f kJ  %.4f kcal" % (dg_net_free,dg_net_free/4.184))
    dg_nets.append(dg_net_free/4.184)
    #USV
    dg_usv_free = compute_usv(0.0,qlig,free_edge)
    print("DG_usv %.4f kJ  %.4f kcal" % (dg_usv_free,dg_usv_free/4.184))
    dg_usvs.append(dg_usv_free/4.184)
    #now compute the RIP term for the free phase
    dg_rip_free, res_int_lig= compute_rip(0.0,qlig,free_edge)
    print("DG_rip %.4f kJ  %.4f kcal" % (dg_rip_free,dg_rip_free/4.184))
    dg_rips.append(dg_rip_free/4.184)
    #empirical term
    dg_emp = compute_emp(0.0,qlig,res_int_lig,free_edge)
    print("DG_emp %.4f kJ  %.4f kcal" % (dg_emp,dg_emp/4.184))
    dg_emps.append(dg_emp/4.184)
    #finally we need to compute the psum or dsc correction
    dg_dsc = compute_dsc(wat,qlig,free_edge)
    print("DG_dsc %.4f kJ  %.4f kcal" % (dg_dsc,dg_dsc/4.184))
    dg_dscs.append(dg_dsc/4.184)
    print(dg_dscs)
    #so the final analytical correction is: NET + USV + RIP + EMP
    ddg_cor = dg_net_free + dg_usv_free + dg_rip_free + dg_emp + dg_dsc
    print("The final correction term for frame %d is DGcor %.4f kJ/mol  or  %.4f kcal/mol" % (i,ddg_cor,ddg_cor/4.184)) 
    #store the correction term
    dg_cors.append(ddg_cor)
    os.chdir("../")#return to previous directory


#remove the directories
cmd = "rm -r analysis-*"
os.system(cmd)
#compute the average
print("Average correction %.4f +/- %.4f kJ/mol or  %.4f +/- %.4f kcal/mol" % (np.mean(dg_cors), np.std(dg_cors), np.mean(dg_cors)/4.184,np.std(dg_cors)/4.184))
ofile = open("freenrg-COULCOR.dat","w")
ofile.write("<DG_NET>\t %.4f \t +/- \t %.4f\n" % (np.mean(dg_nets), np.std(dg_nets)/np.sqrt(len(dg_nets))))
ofile.write("<DG_USV>\t %.4f \t +/- \t %.4f\n" % (np.mean(dg_usvs), np.std(dg_usvs)/np.sqrt(len(dg_usvs))))
ofile.write("<DG_RIP>\t %.4f \t +/- \t %.4f\n" % (np.mean(dg_rips), np.std(dg_rips)/np.sqrt(len(dg_rips))))
ofile.write("<DG_EMP>\t %.4f \t +/- \t %.4f\n" % (np.mean(dg_emps), np.std(dg_emps)/np.sqrt(len(dg_emps))))
ofile.write("<DG_DSC>\t %.4f \t +/- \t %.4f\n" % (np.mean(dg_dscs), np.std(dg_dscs)/np.sqrt(len(dg_dscs))))
ofile.write("<DG_COR>\t %.4f \t +/- \t %.4f\n" % (np.mean(dg_cors)/4.184, np.std(dg_cors)/np.sqrt(len(dg_cors))))


